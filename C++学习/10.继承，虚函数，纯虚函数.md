[toc]

## 访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

我们可以根据访问权限总结出不同的访问类型，如下所示：

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

**一个派生类继承了所有的基类方法，但下列情况除外：**

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

**继承时构造函数与析构函数的执行顺序为：**

父类构造函数->子类构造函数->子类析构函数->父类析构函数

## 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

C++ 类可以从多个类继承成员，语法如下：

```
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

## 虚继承

解决多继承带来的二义性问题`virtual`

## 多态

C++ 默认关闭多态（即使子类重写，也只会调用父类的方法），用虚函数开启多态`virtual`

- 静态多态：编译期就确定执行那个方法；例如重载

- 动态多态：运行时才确定执行那个方法，

## 虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

## 纯虚函数-（Java中的抽象类）

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数

```C++
class Shape {
protected:
    int width;
    int height;
public:
    Shape(int width, int height) : width(width), height(height) {

    }

    /**
     * 虚函数，有方法体
     */
    virtual void describe() {
        cout << "这是一个几何图形" << endl;
    }

    /**
     * 全虚函数，=0，没有方法体，子类必须实现该函数
     */
    virtual int area() = 0;
};
```

## 全纯虚函数 - （Java中的接口）

类中所有的函数都是纯虚函数

## 模板函数 -（Java中的泛型）

```C++
template<typename T>
T plusAction(T t1, T t2) {
    return t1 + t2;
}

int main() {
    plusAction(12, 13);
    plusAction(1.0f, 22.0f);
    plusAction(3.5, 6.1);
    plusAction<string>("AAA","BBB");
    return 0;
}
```

